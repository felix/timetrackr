#!/usr/bin/env ruby

$LOAD_PATH.unshift File.dirname(__FILE__) + '/../lib'

require 'timetrackr'

DEFAULTS = {
  :backend => 'yaml',
  :verbose => false,
  :single_task => false,
  :time_format => "% -30<task>s %2<hours>dh %2<minutes>dm %2<seconds>ds"
}

def show_help
  version = File.exist?('VERSION') ? File.read('VERSION') : ""
  puts "timetrackr version #{version}"
  puts <<HELP

  timetrackr [command] [options]

  Available commands:

      start [task]   start a task (default is 'default')
      stop TASK      stop a task ('all' for all)
      switch TASK    switch tasks
      time [task]    show time for a task ('all' for all)

  Global options
      -h --help      show this help
      -v --verbose   be noisy
HELP
end

def format_time(task, time, fmt_str)
  hours = time.to_i/3600.to_i
  minutes = (time/60 - hours * 60).to_i
  seconds = (time - (minutes * 60 + hours * 3600))
  format(fmt_str,{
    :task => task,
    :hours => hours,
    :minutes => minutes,
    :seconds => seconds})
end

config = {}
config_file = File.join(ENV['HOME'],'.timetrackrrc')
if File.exist?(config_file)
  require 'yaml'
  config = YAML.load_file(config_file)
end

# global options
while (cmd = ARGV.shift) && cmd.start_with?('-')
  if ['-v','--verbose'].include? cmd
    config[:verbose] = true
  end
  if ['-h','--help'].include? cmd
    show_help
    exit 1
  end
end

config = DEFAULTS.merge(config || {})
$verbose = config[:verbose]
trackr = TimeTracker.create(config[:backend])

# 
# commands
#
case cmd
when 'start','s'
  task = ARGV.shift
  details = {:action => 'start', :notes => ARGV.join(' ')}
  if config[:single_task] && trackr.current != task
    trackr.current.each do |t|
      trackr.event(t,Time.now,details.merge(:action => 'stop')) unless t == task
    end
    trackr.event(task,Time.now,details)
    puts "Switched to task '#{task}'" if $verbose
  else
    trackr.event(task,Time.now, details)
    puts "Started task '#{task}'" if $verbose
  end

when 'stop','k'
  task = ARGV.shift
  tasks = []
  details = {:action => 'stop', :notes => ARGV.join(' ')}
  tasks = [*task] if trackr.current.include?(task)
  tasks = trackr.tasks if task == 'all'
  tasks.each do |task|
    trackr.event(task, Time.now, details)
    puts "Stopped task '#{task}'" if $verbose
  end

when 'switch','sw'
  task = ARGV.shift
  details = {:notes => ARGV.join(' ')}
  trackr.current.each do |t|
    trackr.event(t, Time.now, details.merge(:action => 'stop')) unless t == task
  end
  trackr.event(task, Time.now, details.merge(:action => 'start'))
  puts "Switched to task '#{task}'" if $verbose

when 'time', nil
  task = ARGV.shift
  if task && trackr.tasks.include?(task)
    tasks = [*task]
  else
    tasks = trackr.tasks.each
  end
  tasks.each do |task|
    name = trackr.current.include?(task) ? task+' *' : task
    puts format_time(name, trackr.time(task),config[:time_format])
  end

when 'clear'
  task = ARGV.shift
  tasks = []
  tasks = [*task] if trackr.current.include?(task)
  tasks = trackr.tasks if task == 'all'
  tasks.each do |task|
    trackr.clear(task)
    puts "Task '#{task}' cleared" if $verbose
  end

else
  puts "'#{cmd}' is not a valid command"
  show_help
end

trackr.close

#  vim: set ts=2 sw=2 tw=80 ft=ruby fdm=syntax et fen :
