#!/usr/bin/env ruby

$LOAD_PATH.unshift File.dirname(__FILE__) + '/../lib'

require 'timetrackr'
require 'timetrackr/period'

DEFAULTS = {
  'backend' => 'yaml',
  'verbose' => false,
  'single_task' => false,
  'path' => File.join(ENV['HOME'],'.timetrackr.db'),
  'relative_format' => "%2<hours>dh %2<minutes>dm %2<seconds>ds",
  'absolute_time' => "%H:%M",
  'absolute_day' => "%Y-%m-%d"
}

def show_help
  version = File.exist?('VERSION') ? File.read('VERSION') : ""
  puts "timetrackr version #{version}"
  puts <<HELP

  timetrackr [command] [options]

  Available commands:

      start [task]   start a task
      stop [task]    stop a task (or 'all')
      switch TASK    switch tasks
      time [task]    show time for a task (or 'all')
      log [task]     show time log for a task (or 'all')

  Global options
      -h --help      show this help
      -v --verbose   be noisy
HELP
end

def format_time(time, fmt_str)
  hours = time.to_i/3600.to_i
  minutes = (time/60 - hours * 60).to_i
  seconds = (time - (minutes * 60 + hours * 3600))
  format(fmt_str,{
    :hours => hours,
    :minutes => minutes,
    :seconds => seconds})
end

config = {}
config_file = File.join(ENV['HOME'],'.timetrackrrc')
if File.exist?(config_file)
  require 'yaml'
  config = YAML.load_file(config_file)
end

# global options
while (cmd = ARGV.shift) && cmd.start_with?('-')
  if ['-v','--verbose'].include? cmd
    config['verbose'] = true
  end
  if ['-h','--help'].include? cmd
    show_help
    exit 1
  end
end

config = DEFAULTS.merge(config || {})
$verbose = config['verbose']
trackr = TimeTrackr.create(config['backend'], config)

# 
# commands
#
case cmd
when 'start','in','s'
  task = ARGV.shift
  notes = ARGV.join(' ')
  # switch tasks if config says so
  if config['single_task'] && trackr.current != task
    trackr.current.each { |t|
      trackr.stop(t) unless t == task
    }
    puts "Switched to task '#{task}'" if $verbose
  else
    puts "Started task '#{task}'" if $verbose
  end
  trackr.start(task, notes)

when 'stop','out','kill','k'
  if ARGV[0] == 'all' || ARGV[0].nil?
    tasks = trackr.tasks
  else
    tasks = ARGV
  end
  tasks.each do |task|
    trackr.stop(task)
    puts "Stopped task '#{task}'" if $verbose
  end

when 'switch','sw'
  task = ARGV.shift
  notes = ARGV.join(' ')
  trackr.current.each do |t|
    trackr.stop(t) unless t == task
  end
  trackr.start(task, notes)
  puts "Switched to task '#{task}'" if $verbose

when 'time','status',nil
  task = ARGV.shift
  if task && trackr.tasks.include?(task)
    tasks = [*task]
  else
    tasks = trackr.tasks.each
  end
  tasks.each do |task|
    total = trackr.history(task).reduce(0){ |t, period|
      t = t + period.length
    }
    name = trackr.current.include?(task) ? task+' *' : task
    puts name.ljust(15) << format_time(total,config['relative_format'])
  end

when 'log'
  if ARGV[0] == 'all' || ARGV[0].nil?
    tasks = trackr.tasks
  else
    tasks = ARGV
  end
  table = []
  periods = tasks.each.collect{ |t| trackr.history(t) }.flatten
  lastday = nil
  table << periods.sort{|x,y| x.start <=> y.start}.collect{ |period|
    currday = period.start.strftime(config['absolute_day'])
    day = (currday == lastday) ? ' ' : currday
    lastday = currday
    name = period.current? ? period.task+' *' : period.task
    start = period.start.strftime(config['absolute_time'])
    stop = period.current? ? ' ' : period.stop.strftime(config['absolute_time'])
    length = format_time(period.length, config['relative_format'])
    "#{day.ljust(12)} #{name.ljust(15)} #{start.ljust(7)} #{stop.ljust(7)} #{length}"
  }
  puts table


when 'clear','delete','del'
  tasks = ARGV
  tasks = trackr.tasks if task == 'all'
  tasks.each do |task|
    trackr.clear(task)
    puts "Task '#{task}' cleared" if $verbose
  end

else
  puts "'#{cmd}' is not a valid command"
  show_help
end

trackr.close

#  vim: set ts=2 sw=2 tw=80 ft=ruby fdm=syntax et fen :
